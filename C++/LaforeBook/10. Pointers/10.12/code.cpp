/*12. Указатели сложны, поэтому давайте посмотрим, сможем ли мы сделать работу с ними более понятной (или, возможно, более непонятной), используя их симуляцию в классе.
Для разъяснения действия наших доморощенных указателей мы смоделируем память компьютера с помощью массивов. Так как доступ к массивам всем понятен, то вы сможете увидеть, что реально происходит, когда мы используем для доступа к памяти указатели.
Мы будем использовать один массив типа char для хранения всех типов переменных. Именно так устроена память компьютера: массив байтов (тип char имеет тот же размер), каждый из которых имеет адрес (или, в терминах массива, индекс). Однако C++ не позволит нам хранить данные типа float или int в массиве типа char обычным путем (мы можем использовать объединения, но это другая история). Поэтому мы создадим симулятор памяти, используя отдельный массив для каждого типа данных, которые мы хотим сохранить. В этом упражнении мы ограничимся одним типом float, и нам понадобится массив для него. Назовем этот массив fmemory. Однако значения указателей (адреса) тоже хранятся в памяти, и нам понадобится еще один массив для их хранения. Так как в качестве модели адресов мы используем индексы массива, то нам потребуется массив типа int, назовем его pmemory, для хранения этих индексов.
Индекс массива fmemory (назовем его fmem_top) показывает на следующее по очереди доступное место, где можно сохранить значение типа float. У нас есть еще похожий индекс массива pmemory (назовем его pmem_top). Не волнуйтесь о том, что наша «память» может закончиться. Мы предполагаем, что эти массивы достаточно большие, чтобы хранить все, что мы захотим, и нам не надо заботиться об управлении памятью.
Создадим класс Float, который мы будем использовать для моделирования чисел типа float, которые будет храниться в fmemory вместо настоящей памяти. Класс Float содержит поле, значением которого является индекс массива fmemory, хранящего значения типа float. Назовем это поле addr. В классе также должны быть два метода. Первый — это конструктор, имеющий один аргумент типа float для инициализации значения. Конструктор помещает значение аргумента в элемент массива fmemory, на который указывает указатель fmem_top, а затем записывает значение fmem_top в массив addr. Это похоже на то, как компоновщик и компилятор хранят обычные переменные в памяти. Второй метод является перегружаемой операцией &. Он просто возвращает значение указателя (индекса типа int) в addr.
Создадим второй класс ptrFloat. Объект этого класса содержит адрес (индекс) в pmemory. Метод класса инициализирует этот «указатель» значением типа int. Второй метод перегружает операцию * (операция разыменования). Его действия более сложны. Он получает адрес из массива pmemory, в котором хранятся адреса. Затем полученный адрес используется как индекс массива fmemory для получения значения типа float, которое располагалось по нужному нам адресу;
float& ptrFloat::operator*()
{
 return fmemory[pmemory[addr]];
}
Таким образом мы моделируем действия операции разыменования (*). Заметим, что вам нужно возвращаться из этой функции по ссылке, чтобы можно было использовать операцию * слева от знака равно.
Классы Float и ptrFloat похожи, но класс Float хранит данные типа float в массиве, представляющем собой память, а класс ptrFloat хранит поля типа int (являющиеся у нас указателями, но на самом деле индексами массива) в другом массиве, который тоже представляет собой память. Типичное использование этих классов в функции main():
Float var1 = 1.234; // определяем и инициализируем
Float var2 = 5.678; // две вещественные переменные
ptrFloat ptr1 = &var1; // определяем и инициализируем
ptrFloat ptr2 = &var2; // два указателя
cout << " *ptr1 = " << *ptr1; // получаем значения переменных
cout << " *ptr2 = " << *ptr2; // и выводим на экран
*ptr1 = 7.123; // присваиваем новые значения
*ptr2 = 8.456; // переменным, адресованным через указатели
cout << " *ptr1 = " << *ptr1; // снова получаем значения
cout << " *ptr2 = " << *ptr2; // и выводим на экран
Заметим, что за исключением других имен типов переменных, это выглядит так же, как действия с настоящими переменными. Далее результат работы программы:
*ptr1 = 1.234
*ptr2 = 5.678
*ptr1 = 7.123
*ptr2 = 8.456
Такой путь реализации указателей может показаться очень сложным, но здесь показана их внутренняя работа и работа операции адреса. Мы рассмотрели природу указателей в различных ракурсах.*/
#include "../../accessories.h"
float* fmemory;
int* pmemory;
int fmem_top,pmem_top;
class Float
{
	int addr;
	public: Float(float NewValue)
	{
		fmemory[fmem_top]=NewValue;
		addr=fmem_top;
		fmem_top++;		
	}
	float operator&(){return addr;}
};
class ptrFloat
{
	int addr;
	public: ptrFloat(int NewIndex)
	{
		pmemory[pmem_top]=NewIndex;
		addr=pmem_top;
		pmem_top++;
	}
	float& operator*(){return fmemory[pmemory[addr]];}
};
int main(void)
{
	fmemory=new float[100];
	pmemory=new int[100];
	fmem_top=0;
	pmem_top=0;
	Float var1=1.234; //определяем и инициализируем
	Float var2=5.678; //две вещественные переменные	
	ptrFloat ptr1=&var1; //определяем и инициализируем
	ptrFloat ptr2=&var2; //два указателя
	cout<<"*ptr1 = "<<*ptr1<<endl; //получаем значения переменных
	cout<<"*ptr2 = "<<*ptr2<<endl; //и выводим на экран
	*ptr1=7.123; //присваиваем новые значения
	*ptr2=8.456; //переменным, адресованным через указатели
	cout<<"*ptr1 = "<<*ptr1<<endl; //снова получаем значения
	cout<<"*ptr2 = "<<*ptr2<<endl; //и выводим на экран
	return 0;
}
