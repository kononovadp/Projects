//10. Упражнение 4 в главе 10 включало в себя добавление к классу linklist перегружаемого деструктора. Допустим, мы заполняем объект этого класса данными, а затем присваиваем один класс целиком другому, используя стандартный оператор присваивания: list2 = list1; Допустим, что впоследствии мы удалим объект класса list1. Можем ли мы все еще использовать list2 для доступа к введенным данным? Увы, нет, так как при удалении list1 все его ссылки были удалены. Единственное, что было известно объекту linklist про удаленный объект, это указатель на него. Но его удалили, указатель в list2 стал недееспособным, и все попытки получить доступ к данным приведут к получению мусора вместо данных, а в худшем случае — к зависанию программы. Один из способов избежать этих проблем — перегрузить оператор присваивания, чтобы он вместе с объектом копировал бы все его ссылки. Но тогда придется пройти по всей цепочке, поочередно копируя все ссылки. Как отмечалось ранее, следует также перегружать конструктор копирования. Чтобы была возможность удалять объекты linklist в main(), можно создавать их с помощью указателя и new. В таком случае проще будет проверять работу новых операций. Не переживайте, если обнаружите, что в процессе копирования порядок следования данных изменился. Понятно, что копирование всех данных не является самым эффективным решением проблемы с точки зрения экономии памяти. Сравните этот подход с представленным в примере STRIMEM (глава 10), где использовался только один набор данных для всех объектов, и хранилась информация о том, сколько объектов указывали на эти данные.
//Класс String с экономией памяти
//Перегружаемая операция присваивания и конструктор копирования
#include <iostream>
#include <cstring>
using namespace std;
class strCount //Класс-счетчик уникальных строк
{
	int count;
	char* str;
	friend class String; //сделаем себя доступными (методы скрыты)
	strCount(char* s)
	{
		int length=strlen(s);
		str=new char[length+1];
		strcpy(str,s);
		count=1;				 
	}
	~strCount(){delete[] str;}
};
class String
{
	strCount* psc;
	public:
	String()
	{
		char NewStr[]="";
		psc=new strCount(NewStr);
	}
	String(char* s){psc=new strCount(s);}
	String(String& S)
	{
		psc=S.psc;
		(psc->count)++;
	}
	~String()
	{
		if(psc->count==1) //если последний пользователь,
			delete psc; //удалить strCount
		else //иначе
			(psc->count)--; //уменьшить счетчик
	}
	void display()
	{
		cout<<psc->str; //вывести строку
		cout<<" (addr = "<<psc<<"); count: "<<psc->count; //вывести адрес
	}
	void operator=(String& S) //присвоение String
	{
		if(psc->count==1) //если последний пользователь,
			delete psc; //удалить strCount
		else //иначе
			(psc->count)--; //уменьшить счетчик
		psc=S.psc; //использовать strCount аргумента
		(psc->count)++;
	}
};
int main()
{
	char NewString[]="A fly was walking across the field and found money.";
	String s3=NewString;
	cout<<"s3 =";
	s3.display();
	String s1;
	s1=s3;
	cout<<"\ns1 =";
	s1.display();
	String s2(s3);
	cout<<"\ns2 =";
	s2.display();
	cout<<endl;
	return 0;
}