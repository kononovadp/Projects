/*8. Другим недостатком C++ является отсутствие автоматической проверки индексов массива на соответствие их границам массива (это делает действия с массивами быстрыми, но менее надежными). Мы можем использовать класс для создания надежного массива, который проверяет индексы при любой попытке доступа к массиву. Напишите класс safearay, который использует массив типа int фиксированного размера (назовем его LIMIT) в качестве своей единственной переменной. В классе будет два метода. Первый, putel(), принимает индекс и значение типа int как аргументы и вставляет это значение в массив по заданному индексу. Второй, getel(), принимает индекс как аргумент и возвращает значение типа int, содержащееся в элементе с этим индексом.
safearay sa1: //описываем массив;
int temp = 12345; //описываем целое;
sa1.putel(7, temp); //помещаем значение temp в массив;
temp = sa1.getel(7); //получаем значение из массива.
Оба метода должны проверять индекс аргумента, чтобы быть уверенными, что он не меньше 0 и не больше, чем LIMIT-1. Вы можете использовать этот массив без опаски, что запись будет произведена в другие части памяти. Использование методов для доступа к элементам массива не выглядит так наглядно, как использование операции []. В главе 8 мы увидим, как перегрузить эту операцию, чтобы сделать работу нашего класса safearay похожей на работу встроенных массивов.*/
#include <iostream>
#include <conio.h>
using namespace std;
const int arrsize=100;
class safearay
{
	int LIMIT[arrsize];
	public:
	void putel(int ind, int val)
	{
		if(ind>-1 && ind<arrsize)
			LIMIT[ind]=val;
	}
	int getel(int ind)
	{
		if(ind>0 && ind<arrsize)
			return LIMIT[ind];
	}
};
int main(void)
{
	safearay sa1; //описываем массив;
	int temp = 12345; //описываем целое;
	sa1.putel(7, temp); //помещаем значение temp в массив;
	temp = sa1.getel(7); //получаем значение из массива.
	return 0;
}
