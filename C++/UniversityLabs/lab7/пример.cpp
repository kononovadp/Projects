#include <iostream>
using namespace std;
 
struct Node //Звено дерева
{
   int x; //То, что записываем в дерево
   Node *l,*r; //Это указатели на новые звенья
};
 
void show(Node *&Tree) //Функция обхода
{
	if (Tree!=NULL) //Пока не встретится пустое звено
	{
	   show(Tree->l); //Рекурсивная функция для вывода левого поддерева
	   cout<<Tree->x; //Отображаем корень дерева
	   show(Tree->r); //Рекурсивная функци для вывода правого поддерева
	}
}
 
/*Добавили очистку памяти*/
void del(Node *&Tree){
   if (Tree!=NULL) //Пока не встретится пустое звено
	{
	   del(Tree->l); //Рекурсивная функция прохода по левому поддереву
	   del(Tree->r); //Рекурсивная функци для прохода по правому поддереву
	   delete Tree; //Убиваем конечный элемент дерева
	   Tree = NULL; //Может и не обязательно, но плохого не будет
	}
 
}
 
void add_node(int x,Node *&MyTree) //Фукция добавления звена в дерево
{
	if (NULL==MyTree)  //То, о чем я в самом начале писал. Если дерева нет, то ложим семечко
	{
		MyTree=new Node; //Выделяем память под звено дерева
		MyTree->x=x; //Записываем данные в звено
		MyTree->l=MyTree->r=NULL; //Подзвенья инициализируем пустотой во избежание ошибок
	}
 
                   if (x<MyTree->x)   //Если нововведенный элемент x меньше чем элемент x из семечка дерева, уходим влево
                      {
                          if (MyTree->l!=NULL) add_node(x,MyTree->l); //При помощи рекурсии заталкиваем элемент на свободный участок
                          else //Если элемент получил свой участок, то
                          {
                              MyTree->l=new Node;  //Выделяем память левому подзвену. Именно подзвену, а не просто звену
                              MyTree->l->l=MyTree->l->r=NULL; //У левого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
                              MyTree->l->x=x; //Записываем в левое подзвено записываемый элемент
                          }
                      }
 
                    if (x>MyTree->x)   //Если нововведенный элемент x больше чем элемент x из семечка дерева, уходим вправо
                      {
                          if (MyTree->r!=NULL) add_node(x,MyTree->r); //При помощи рекурсии заталкиваем элемент на свободный участок
                          else //Если элемент получил свой участок, то
                          {
                              MyTree->r=new Node;  //Выделяем память правому подзвену. Именно подзвену, а не просто звену
                              MyTree->r->l=MyTree->r->r=NULL; //У правого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
                              MyTree->r->x=x; //Записываем в правое подзвено записываемый элемент
                          }
                      }
}
 
int main()
{
   Node *Tree=NULL;  //Создаю указатель, тип которого = звено дерева и инициализирую его пустотой
	  for (int i=5;i>0;i--) add_node(i,Tree); //Это я забивал 5-4-3-2-1, а вывод сами увидите
	 show(Tree); //Вывод на экран дерева. или просто обход дерева
	 cout << '\n';
	  del(Tree);
}